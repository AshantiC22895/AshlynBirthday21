<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pac-Ashley: Chase My Heart</title>
<style>
  body {
    margin: 0;
    background: black;
    color: white;
    font-family: Arial, sans-serif;
    text-align: center;
  }
  canvas {
    background: black;
    display: block;
    margin: 2rem auto;
    border: 4px solid #222;
    border-radius: 10px;
  }
  #game-info {
    font-size: 1.2rem;
    margin-bottom: 0.5rem;
  }
</style>
</head>
<body>

<h1>Pac-Ashley: Chase My Heart ðŸ’–</h1>
<div id="game-info">Use arrow keys to move Ashley and collect all hearts! Avoid ghosts!</div>
<canvas id="game" width="640" height="640"></canvas>
<div id="message" style="margin-top:1rem; font-size:1.3rem;"></div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const tileSize = 32; // 20x20 tiles in 640x640
  const rows = 20;
  const cols = 20;

  // Maze grid: 0=empty, 1=wall
  // Simple Pac-Man style maze with corridors
  // You can expand or customize this maze
  const maze = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],
    [1,0,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,1,0,1],
    [1,0,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,1],
    [1,0,1,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1],
    [1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1],
    [1,0,1,0,1,0,1,0,0,0,0,0,0,1,0,1,0,1,0,1],
    [1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,0,1],
    [1,1,1,1,1,0,1,1,1,0,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1],
    [1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];

  // Player (Ashley)
  const player = {
    x: 1, y: 1,
    px: 1, py: 1,       // precise position for smooth movement
    dir: null,          // current direction moving
    nextDir: null,      // next direction requested
    speed: 0.12
  };

  // Ghosts - 4 classic colors and starting positions
  const ghosts = [
    {x: 9, y: 9, px:9, py:9, color:"#ff0000", dir:"left", speed: 0.10},  // Red
    {x: 10, y: 9, px:10, py:9, color:"#00ffff", dir:"right", speed: 0.09}, // Cyan
    {x: 9, y: 10, px:9, py:10, color:"#ffb8ff", dir:"up", speed: 0.085},  // Pink
    {x: 10, y: 10, px:10, py:10, color:"#ffff00", dir:"down", speed: 0.08} // Yellow
  ];

  // Hearts (dots) on all empty tiles except player start and ghost start
  const hearts = [];
  for(let y=0; y<rows; y++) {
    for(let x=0; x<cols; x++) {
      if(maze[y][x] === 0 && !(x === player.x && y === player.y) && !(ghosts.some(g => g.x === x && g.y === y))) {
        hearts.push({x, y, collected:false});
      }
    }
  }

  // Key handling
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key] = true;
    e.preventDefault();
  });
  window.addEventListener('keyup', e => {
    keys[e.key] = false;
    e.preventDefault();
  });

  // Helper: check if tile is wall
  function isWall(x,y){
    return maze[y] === undefined || maze[y][x] === undefined || maze[y][x] === 1;
  }

  // Helper: opposite directions
  function oppositeDir(d1,d2){
    return (d1 === "left" && d2 === "right") ||
           (d1 === "right" && d2 === "left") ||
           (d1 === "up" && d2 === "down") ||
           (d1 === "down" && d2 === "up");
  }

  // Try to move entity by direction if no wall blocking
  function canMove(x,y,dir) {
    if(dir === "left") return !isWall(x-1,y);
    if(dir === "right") return !isWall(x+1,y);
    if(dir === "up") return !isWall(x,y-1);
    if(dir === "down") return !isWall(x,y+1);
    return false;
  }

  // Game state
  let gameOver = false;
  let win = false;

  // Game Loop
  function update() {
    if(gameOver || win) return;

    // Update player direction from keys
    if(keys["ArrowLeft"]) player.nextDir = "left";
    else if(keys["ArrowRight"]) player.nextDir = "right";
    else if(keys["ArrowUp"]) player.nextDir = "up";
    else if(keys["ArrowDown"]) player.nextDir = "down";

    // Try change direction if possible
    if(player.nextDir && player.nextDir !== player.dir) {
      if(canMove(Math.round(player.px), Math.round(player.py), player.nextDir)){
        player.dir = player.nextDir;
      }
    }

    // Move player smoothly
    if(player.dir && canMove(Math.round(player.px), Math.round(player.py), player.dir)) {
      if(player.dir === "left") player.px -= player.speed;
      else if(player.dir === "right") player.px += player.speed;
      else if(player.dir === "up") player.py -= player.speed;
      else if(player.dir === "down") player.py += player.speed;

      // Update tile position when center passed
      player.x = Math.round(player.px);
      player.y = Math.round(player.py);
    }

    // Eat hearts
    hearts.forEach(h => {
      if(!h.collected && Math.abs(h.x - player.px) < 0.3 && Math.abs(h.y - player.py) < 0.3) {
        h.collected = true;
      }
    });

    // Move ghosts - simple random movement at tile centers
    ghosts.forEach(g => {
      // Move ghost smoothly
      if(g.dir === "left") g.px -= g.speed;
      else if(g.dir === "right") g.px += g.speed;
      else if(g.dir === "up") g.py -= g.speed;
      else if(g.dir === "down") g.py += g.speed;

      // Update tile position
      g.x = Math.round(g.px);
      g.y = Math.round(g.py);

      // If ghost roughly at center of tile, decide new direction
      if(Math.abs(g.px - g.x) < 0.1 && Math.abs(g.py - g.y) < 0.1) {
        const possibleDirs = ["left","right","up","down"].filter(dir => {
          if(oppositeDir(dir, g.dir)) return false; // Don't reverse
          return canMove(g.x, g.y, dir);
        });
        if(possibleDirs.length) {
          g.dir = possibleDirs[Math.floor(Math.random()*possibleDirs.length)];
        }
      }
    });

    // Check collisions between player and ghosts
    ghosts.forEach(g => {
      if(Math.abs(g.px - player.px) < 0.5 && Math.abs(g.py - player.py) < 0.5){
        gameOver = true;
        document.getElementById("message").textContent = "ðŸ’” Ashley was caught by a ghost! Try again!";
      }
    });

    // Check win condition
    if(hearts.every(h => h.collected)) {
      win = true;
      document.getElementById("message").textContent = "ðŸ’– Ashley collected all hearts! You win!";
    }
  }

  // Draw functions
  function draw() {
    // Clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Draw maze
    for(let y=0; y<rows; y++) {
      for(let x=0; x<cols; x++) {
        if(maze[y][x] === 1){
          ctx.fillStyle = "#2222ff";
          ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
          // Draw walls with some shadow and highlight for style
          ctx.strokeStyle = "#99ccff";
          ctx.lineWidth = 2;
          ctx.strokeRect(x*tileSize+2, y*tileSize+2, tileSize-4, tileSize-4);
        }
      }
    }

    // Draw hearts
    hearts.forEach(h => {
      if(!h.collected){
        const cx = h.x*tileSize + tileSize/2;
        const cy = h.y*tileSize + tileSize/2;
        ctx.fillStyle = "#ff4081";
        ctx.beginPath();
        // Draw simple heart shape
        ctx.moveTo(cx, cy);
        ctx.bezierCurveTo(cx, cy-6, cx-8, cy-6, cx-8, cy+1);
        ctx.bezierCurveTo(cx-8, cy+9, cx, cy+14, cx, cy+18);
        ctx.bezierCurveTo(cx, cy+14, cx+8, cy+9, cx+8, cy+1);
        ctx.bezierCurveTo(cx+8, cy-6, cx, cy-6, cx, cy);
        ctx.fill();
      }
    });

    // Draw ghosts
    ghosts.forEach(g => {
      const cx = g.px*tileSize + tileSize/2;
      const cy = g.py*tileSize + tileSize/2;
      ctx.fillStyle = g.color;
      ctx.beginPath();
      // Ghost body (semi-circle + bottom "legs")
      ctx.arc(cx, cy, tileSize/2 - 4, Math.PI, 0, false);
      ctx.lineTo(cx + tileSize/2 - 4, cy + tileSize/2 - 6);
      for(let i=1; i<=4; i++){
        ctx.lineTo(cx + tileSize/2 - 4 - (i * (tileSize/4)), cy + (i % 2 === 0 ? tileSize/2 - 12 : tileSize/2 - 6));
      }
      ctx.closePath();
      ctx.fill();

      // Eyes
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.ellipse(cx - 8, cy - 5, 6, 9, 0, 0, Math.PI*2);
      ctx.ellipse(cx + 8, cy - 5, 6, 9, 0, 0, Math.PI*2);
      ctx.fill();

      // Pupils
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.ellipse(cx - 8 + (Math.cos(Date.now() * 0.005) * 2), cy - 5, 3, 5, 0, 0, Math.PI*2);
      ctx.ellipse(cx + 8 + (Math.cos(Date.now() * 0.005 + 1) * 2), cy - 5, 3, 5, 0, 0, Math.PI*2);
      ctx.fill();
    });

    // Draw player (Ashley) - pink circle with eyes
    const px = player.px*tileSize + tileSize/2;
    const py = player.py*tileSize + tileSize/2;
    ctx.fillStyle = "#e91e63";
    ctx.beginPath();
    ctx.arc(px, py, tileSize/2 - 3, 0, Math.PI*2);
    ctx.fill();

    // Eyes - simple style
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.ellipse(px - 6, py - 5, 6, 9, 0, 0, Math.PI*2);
    ctx.ellipse(px + 6, py - 5, 6, 9, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(px - 6, py - 5, 3, 5, 0, 0, Math.PI*2);
    ctx.ellipse(px + 6, py - 5, 3, 5, 0, 0, Math.PI*2);
    ctx.fill();
  }

  function loop() {
    update();
    draw();
    if(!gameOver && !win) requestAnimationFrame(loop);
  }

  loop();
})();
</script>

</body>
</html>
